//! generated by flatc-zig from Message.fbs

const flatbuffers = @import("flatbuffers");
const std = @import("std");
const types = @import("lib.zig");


/// ----------------------------------------------------------------------
/// The root Message type
/// This union enables us to easily send different message types without
/// redundant storage, and in the future we can easily add new message types.
///
/// Arrow implementations do not need to implement all of the message types,
/// which may include experimental metadata types. For maximum compatibility,
/// it is best to send data using RecordBatch
pub const MessageHeader = union(PackedMessageHeader.Tag) {
    none,
    schema: types.Schema,
    dictionary_batch: types.DictionaryBatch,
    record_batch: types.RecordBatch,

    const Self = @This();

    pub fn init(allocator: std.mem.Allocator, packed_: PackedMessageHeader) flatbuffers.Error!Self {
        return switch (packed_) {
            .none => .none,
            .schema => |t| .{ .schema = try types.Schema.init(allocator, t) },
            .dictionary_batch => |t| .{ .dictionary_batch = try types.DictionaryBatch.init(allocator, t) },
            .record_batch => |t| .{ .record_batch = try types.RecordBatch.init(allocator, t) },
        };
    }

    pub fn deinit(self: Self, allocator: std.mem.Allocator) void {
        switch (self) {
            .schema => {
                self.schema.deinit(allocator);
            },
            .dictionary_batch => {
                self.dictionary_batch.deinit(allocator);
            },
            .record_batch => {
                self.record_batch.deinit(allocator);
            },
            else => {},
        }
    }

    pub fn pack(self: Self, builder: *flatbuffers.Builder) flatbuffers.Error!u32 {
        switch (self) {
            inline else => |v| {
                if (comptime flatbuffers.isScalar(@TypeOf(v))) {
                    try builder.prepend(v);
                    return builder.offset();
                }
                return try v.pack(builder);
            },
        }
    }
};


/// ----------------------------------------------------------------------
/// The root Message type
/// This union enables us to easily send different message types without
/// redundant storage, and in the future we can easily add new message types.
///
/// Arrow implementations do not need to implement all of the message types,
/// which may include experimental metadata types. For maximum compatibility,
/// it is best to send data using RecordBatch
pub const PackedMessageHeader = union(enum) {
    none,
    schema: types.PackedSchema,
    dictionary_batch: types.PackedDictionaryBatch,
    record_batch: types.PackedRecordBatch,

    pub const Tag = std.meta.Tag(@This());
};
