//! generated by flatc-zig from Schema.fbs

const flatbuffers = @import("flatbuffers");

/// Exact decimal value represented as an integer value in two's
/// complement. Currently only 128-bit (16-byte) and 256-bit (32-byte) integers
/// are used. The representation uses the endianness indicated
/// in the Schema.
pub const Decimal = struct {
    /// Total number of decimal digits
    precision: i32 = 0,
    /// Number of digits after the decimal point "."
    scale: i32 = 0,
    /// Number of bits per value. The only accepted widths are 128 and 256.
    /// We use bitWidth for consistency with Int::bitWidth.
    bit_width: i32 = 128,

    const Self = @This();

    pub fn init(packed_: PackedDecimal) flatbuffers.Error!Self {
        return .{
            .precision = try packed_.precision(),
            .scale = try packed_.scale(),
            .bit_width = try packed_.bitWidth(),
        };
    }

    pub fn pack(self: Self, builder: *flatbuffers.Builder) flatbuffers.Error!u32 {
        try builder.startTable();
        try builder.appendTableFieldWithDefault(i32, self.precision, 0);
        try builder.appendTableFieldWithDefault(i32, self.scale, 0);
        try builder.appendTableFieldWithDefault(i32, self.bit_width, 128);
        return builder.endTable();
    }
};

/// Exact decimal value represented as an integer value in two's
/// complement. Currently only 128-bit (16-byte) and 256-bit (32-byte) integers
/// are used. The representation uses the endianness indicated
/// in the Schema.
pub const PackedDecimal = struct {
    table: flatbuffers.Table,

    const Self = @This();

    pub fn init(size_prefixed_bytes: []u8) flatbuffers.Error!Self {
        return .{ .table = try flatbuffers.Table.init(size_prefixed_bytes) };
    }

    /// Total number of decimal digits
    pub fn precision(self: Self) flatbuffers.Error!i32 {
        return self.table.readFieldWithDefault(i32, 0, 0);
    }

    /// Number of digits after the decimal point "."
    pub fn scale(self: Self) flatbuffers.Error!i32 {
        return self.table.readFieldWithDefault(i32, 1, 0);
    }

    /// Number of bits per value. The only accepted widths are 128 and 256.
    /// We use bitWidth for consistency with Int::bitWidth.
    pub fn bitWidth(self: Self) flatbuffers.Error!i32 {
        return self.table.readFieldWithDefault(i32, 2, 128);
    }
};
