//! generated by flatc-zig from Schema.fbs

const flatbuffers = @import("flatbuffers");
const types = @import("lib.zig");

/// Time is either a 32-bit or 64-bit signed integer type representing an
/// elapsed time since midnight, stored in either of four units: seconds,
/// milliseconds, microseconds or nanoseconds.
///
/// The integer `bitWidth` depends on the `unit` and must be one of the following:
/// * SECOND and MILLISECOND: 32 bits
/// * MICROSECOND and NANOSECOND: 64 bits
///
/// The allowed values are between 0 (inclusive) and 86400 (=24*60*60) seconds
/// (exclusive), adjusted for the time unit (for example, up to 86400000
/// exclusive for the MILLISECOND unit).
/// This definition doesn't allow for leap seconds. Time values from
/// measurements with leap seconds will need to be corrected when ingesting
/// into Arrow (for example by replacing the value 86400 with 86399).
pub const Time = struct {
    unit: types.TimeUnit = .millisecond,
    bit_width: i32 = 32,

    const Self = @This();

    pub fn init(packed_: PackedTime) flatbuffers.Error!Self {
        return .{
            .unit = try packed_.unit(),
            .bit_width = try packed_.bitWidth(),
        };
    }

    pub fn pack(self: Self, builder: *flatbuffers.Builder) flatbuffers.Error!u32 {
        try builder.startTable();
        try builder.appendTableFieldWithDefault(types.TimeUnit, self.unit, .millisecond);
        try builder.appendTableFieldWithDefault(i32, self.bit_width, 32);
        return builder.endTable();
    }
};

/// Time is either a 32-bit or 64-bit signed integer type representing an
/// elapsed time since midnight, stored in either of four units: seconds,
/// milliseconds, microseconds or nanoseconds.
///
/// The integer `bitWidth` depends on the `unit` and must be one of the following:
/// * SECOND and MILLISECOND: 32 bits
/// * MICROSECOND and NANOSECOND: 64 bits
///
/// The allowed values are between 0 (inclusive) and 86400 (=24*60*60) seconds
/// (exclusive), adjusted for the time unit (for example, up to 86400000
/// exclusive for the MILLISECOND unit).
/// This definition doesn't allow for leap seconds. Time values from
/// measurements with leap seconds will need to be corrected when ingesting
/// into Arrow (for example by replacing the value 86400 with 86399).
pub const PackedTime = struct {
    table: flatbuffers.Table,

    const Self = @This();

    pub fn init(size_prefixed_bytes: []u8) flatbuffers.Error!Self {
        return .{ .table = try flatbuffers.Table.init(size_prefixed_bytes) };
    }

    pub fn unit(self: Self) flatbuffers.Error!types.TimeUnit {
        return self.table.readFieldWithDefault(types.TimeUnit, 0, .millisecond);
    }

    pub fn bitWidth(self: Self) flatbuffers.Error!i32 {
        return self.table.readFieldWithDefault(i32, 1, 32);
    }
};
