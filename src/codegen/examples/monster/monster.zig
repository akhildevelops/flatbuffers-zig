//! generated by flatc-zig from tmp.fbs

const flatbuffers = @import("flatbuffers");
const std = @import("std");

pub const Color = enum(i8) {
    red = 0,
    green = 1,
    blue = 2,
};

pub const Equipment = union(PackedEquipment.Tag) {
    none,
    weapon: Weapon,

    const Self = @This();

    pub fn init(allocator: std.mem.Allocator, packed_: PackedEquipment) !Self {
        return switch (packed_) {
            .none => .none,
            .weapon => |w| .{ .weapon = try Weapon.init(allocator, w) },
        };
    }

    pub fn deinit(self: Self, allocator: std.mem.Allocator) void {
        switch (self) {
            .weapon => {
                self.weapon.deinit(allocator);
            },
            else => {},
        }
    }

    pub fn pack(self: Self, builder: *flatbuffers.Builder) !u32 {
        switch (self) {
            inline else => |v| {
                if (comptime flatbuffers.isPacked(@TypeOf(v))) {
                    try builder.prepend(v);
                    return builder.offset();
                }
                return try v.pack(builder);
            },
        }
    }
};

pub const PackedEquipment = union(enum) {
    none,
    weapon: PackedWeapon,

    pub const Tag = std.meta.Tag(@This());
};

pub const Monster = struct {
    pos: ?Vec3 = null,
    mana: i16 = 150,
    hp: i16 = 100,
    name: [:0]const u8,
    inventory: []u8,
    color: Color = @intToEnum(Color, 2),
    weapons: []Weapon,
    equipped: Equipment,
    path: []Vec3,
    rotation: ?Vec4 = null,

    const Self = @This();

    pub fn init(allocator: std.mem.Allocator, packed_: PackedMonster) !Self {
        return .{
            .pos = try packed_.pos(),
            .mana = try packed_.mana(),
            .hp = try packed_.hp(),
            .name = try packed_.name(),
            .inventory = try packed_.inventory(),
            .color = try packed_.color(),
            .weapons = try flatbuffers.unpackVector(allocator, Weapon, packed_, "weapons"),
            .equipped = try Equipment.init(allocator, try packed_.equipped()),
            .path = try flatbuffers.unpackVector(allocator, Vec3, packed_, "path"),
            .rotation = try packed_.rotation(),
        };
    }

    pub fn deinit(self: Self, allocator: std.mem.Allocator) void {
        for (self.weapons) |w| w.deinit(allocator);
        allocator.free(self.weapons);
        self.equipped.deinit(allocator);
        allocator.free(self.path);
    }

    pub fn pack(self: Self, builder: *flatbuffers.Builder) !u32 {
        const field_offsets = .{
            .name = try builder.prependString(self.name),
            .inventory = try builder.prependVector(u8, self.inventory),
            .weapons = try builder.prependVectorOffsets(Weapon, self.weapons),
            .equipped = try self.equipped.pack(builder),
            .path = try builder.prependVector(Vec3, self.path),
        };

        try builder.startTable();
        try builder.appendTableField(?Vec3, self.pos);
        try builder.appendTableField(i16, self.mana);
        try builder.appendTableField(i16, self.hp);
        try builder.appendTableFieldOffset(field_offsets.name);
        try builder.appendTableFieldOffset(0);
        try builder.appendTableFieldOffset(field_offsets.inventory);
        try builder.appendTableField(Color, self.color);
        try builder.appendTableFieldOffset(field_offsets.weapons);
        try builder.appendTableField(PackedEquipment.Tag, self.equipped);
        try builder.appendTableFieldOffset(field_offsets.equipped);
        try builder.appendTableFieldOffset(field_offsets.path);
        try builder.appendTableField(?Vec4, self.rotation);
        return builder.endTable();
    }
};

pub const PackedMonster = struct {
    table: flatbuffers.Table,

    const Self = @This();

    pub fn init(size_prefixed_bytes: []u8) !Self {
        return .{ .table = try flatbuffers.Table.init(size_prefixed_bytes) };
    }

    pub fn pos(self: Self) !?Vec3 {
        return self.table.readField(?Vec3, 0);
    }

    pub fn mana(self: Self) !i16 {
        return self.table.readFieldWithDefault(i16, 1, 150);
    }

    pub fn hp(self: Self) !i16 {
        return self.table.readFieldWithDefault(i16, 2, 100);
    }

    pub fn name(self: Self) ![:0]const u8 {
        return self.table.readField([:0]const u8, 3);
    }

    pub fn inventory(self: Self) ![]align(1) u8 {
        return self.table.readField([]align(1) u8, 5);
    }

    pub fn color(self: Self) !Color {
        return self.table.readFieldWithDefault(Color, 6, @intToEnum(Color, 2));
    }

    pub fn weaponsLen(self: Self) !u32 {
        return self.table.readFieldVectorLen(7);
    }
    pub fn weapons(self: Self, index: usize) !PackedWeapon {
        return self.table.readFieldVectorItem(PackedWeapon, 7, index);
    }

    pub fn equippedType(self: Self) !PackedEquipment.Tag {
        return self.table.readFieldWithDefault(PackedEquipment.Tag, 8, @intToEnum(PackedEquipment.Tag, 0));
    }

    pub fn equipped(self: Self) !PackedEquipment {
        return switch (try self.equippedType()) {
            inline else => |t| {
                var result = @unionInit(PackedEquipment, @tagName(t), undefined);
                const field = &@field(result, @tagName(t));
                field.* = try self.table.readField(@TypeOf(field.*), 9);
                return result;
            },
        };
    }

    pub fn path(self: Self) ![]align(1) Vec3 {
        return self.table.readField([]align(1) Vec3, 10);
    }

    pub fn rotation(self: Self) !?Vec4 {
        return self.table.readField(?Vec4, 11);
    }
};

pub const Vec3 = extern struct {
    x: f32,
    y: f32,
    z: f32,
};

pub const Vec4 = extern struct {
    v: [4]f32,
};

pub const Weapon = struct {
    name: [:0]const u8,
    damage: i16 = 0,
    owners: [][:0]const u8,

    const Self = @This();

    pub fn init(allocator: std.mem.Allocator, packed_: PackedWeapon) !Self {
        return .{
            .name = try packed_.name(),
            .damage = try packed_.damage(),
            .owners = try flatbuffers.unpackVector(allocator, [:0]const u8, packed_, "owners"),
        };
    }

    pub fn deinit(self: Self, allocator: std.mem.Allocator) void {
        allocator.free(self.owners);
    }

    pub fn pack(self: Self, builder: *flatbuffers.Builder) !u32 {
        const field_offsets = .{
            .name = try builder.prependString(self.name),
            .owners = try builder.prependVectorOffsets([:0]const u8, self.owners),
        };

        try builder.startTable();
        try builder.appendTableFieldOffset(field_offsets.name);
        try builder.appendTableField(i16, self.damage);
        try builder.appendTableFieldOffset(field_offsets.owners);
        return builder.endTable();
    }
};

pub const PackedWeapon = struct {
    table: flatbuffers.Table,

    const Self = @This();

    pub fn init(size_prefixed_bytes: []u8) !Self {
        return .{ .table = try flatbuffers.Table.init(size_prefixed_bytes) };
    }

    pub fn name(self: Self) ![:0]const u8 {
        return self.table.readField([:0]const u8, 0);
    }

    pub fn damage(self: Self) !i16 {
        return self.table.readFieldWithDefault(i16, 1, 0);
    }

    pub fn ownersLen(self: Self) !u32 {
        return self.table.readFieldVectorLen(2);
    }
    pub fn owners(self: Self, index: usize) ![:0]const u8 {
        return self.table.readFieldVectorItem([:0]const u8, 2, index);
    }
};
