//!
//! generated by flatc-zig
//! schema:     reflection.fbs
//! typename    Type
//!
//! Modified to add convienence methods.

const std = @import("std");
const flatbuffers = @import("flatbuffers");
const Types = @import("./lib.zig");

pub const ChildType = union(enum) {
    scalar: Types.BaseType,
    @"enum": Types.Enum,
    object: Types.Object,

    const Self = @This();
    const Tag = std.meta.Tag(Self);

    pub fn name(self: Self) []const u8 {
        return switch (self) {
            .scalar => |s| s.name(),
            inline else => |o| o.name,
        };
    }

    pub fn declarationFile(self: Self) []const u8 {
        return switch (self) {
            .scalar => "",
            inline else => |o| o.declaration_file,
        };
    }

    pub fn @"type"(self: Self) !Type {
        return switch (self) {
            .scalar => |s| Type{
                .base_type = s,
                .index = 0,
            },
            .@"enum" => |e| e.underlying_type,
            .object => Type{
                .base_type = .obj,
                .index = 0,
            },
        };
    }

    pub fn isStruct(self: Self) !bool {
        return switch (self) {
            .object => |o| o.is_struct,
            else => false,
        };
    }
};

pub const Type = struct {
    base_type: Types.BaseType = @intToEnum(Types.BaseType, 0),
    element: Types.BaseType = @intToEnum(Types.BaseType, 0),
    index: i32 = -1,
    fixed_length: u16 = 0,
    base_size: u32 = 4,
    element_size: u32 = 0,
    // These allow for a recursive `CodeWriter.getType`
    is_optional: bool = false,
    is_packed: bool = false,

    const Self = @This();

    pub fn init(packed_: PackedType) !Self {
        return .{
            .base_type = try packed_.baseType(),
            .element = try packed_.element(),
            .index = try packed_.index(),
            .fixed_length = try packed_.fixedLength(),
            .base_size = try packed_.baseSize(),
            .element_size = try packed_.elementSize(),
        };
    }

    pub fn pack(self: Self, builder: *flatbuffers.Builder) !u32 {
        try builder.startTable();
        try builder.appendTableField(Types.BaseType, self.base_type);
        try builder.appendTableField(Types.BaseType, self.element);
        try builder.appendTableField(i32, self.index);
        try builder.appendTableField(u16, self.fixed_length);
        try builder.appendTableField(u32, self.base_size);
        try builder.appendTableField(u32, self.element_size);
        return builder.endTable();
    }

    // Added declarations to aid codegen
    pub fn child(self: Self, schema: Types.Schema) !?ChildType {
        switch (self.base_type) {
            .array, .vector => {
                if (self.element.isScalar()) return .{ .scalar = self.element };
                const next_type = Self{
                    .base_type = self.element,
                    .index = self.index,
                    .is_packed = self.is_packed,
                };
                return next_type.child(schema);
            },
            .obj => {
                if (self.index != -1)
                    return ChildType{ .object = schema.objects[@intCast(usize, self.index)] };
            },
            // Sometimes integer types are disguised as enums
            .utype, .@"union", .byte, .ubyte, .short, .ushort, .int, .uint, .long, .ulong => {
                if (self.index != -1)
                    return ChildType{ .@"enum" = schema.enums[@intCast(usize, self.index)] };
            },
            else => {},
        }
        return null;
    }

    pub fn isIndirect(self: Self, schema: Types.Schema) !bool {
        if (self.base_type == .vector) {
            if (try self.child(schema)) |c| {
                const child_type: Type = try c.type();
                if (!child_type.base_type.isScalar()) return c.isStruct();
            }
        }
        return false;
    }

    pub fn isAllocated(self: Self, schema: Types.Schema) !bool {
        if (self.base_type == .vector) {
            if (try self.child(schema)) |c| {
                const child_type: Type = try c.type();
                if (!child_type.base_type.isScalar()) return true;
            }
        }
        return false;
    }
};

pub const PackedType = struct {
    table: flatbuffers.Table,

    const Self = @This();

    pub fn init(size_prefixed_bytes: []u8) !Self {
        return .{ .table = try flatbuffers.Table.init(size_prefixed_bytes) };
    }

    pub fn baseType(self: Self) !Types.BaseType {
        return self.table.readFieldWithDefault(Types.BaseType, 0, @intToEnum(Types.BaseType, 0));
    }

    pub fn element(self: Self) !Types.BaseType {
        return self.table.readFieldWithDefault(Types.BaseType, 1, @intToEnum(Types.BaseType, 0));
    }

    pub fn index(self: Self) !i32 {
        return self.table.readFieldWithDefault(i32, 2, -1);
    }

    pub fn fixedLength(self: Self) !u16 {
        return self.table.readFieldWithDefault(u16, 3, 0);
    }

    pub fn baseSize(self: Self) !u32 {
        return self.table.readFieldWithDefault(u32, 4, 4);
    }

    pub fn elementSize(self: Self) !u32 {
        return self.table.readFieldWithDefault(u32, 5, 0);
    }
};
