//!
//! generated by flatc-zig
//! binary:     ./examples/monster/monster.fbs
//! schema:     monster.fbs
//! file ident: //monster.fbs
//! typename    Vec3
//!

const flatbufferz = @import("flatbufferz");

pub const Vec3 = struct {
    x: f32,
    y: f32,
    z: f32,

    const Self = @This();

    pub fn init(packed_struct: PackedVec3) !Self {
        return .{
            .x = packed_struct.x(),
            .y = packed_struct.y(),
            .z = packed_struct.z(),
        };
    }

    pub fn pack(self: Self, builder: *flatbufferz.Builder) !u32 {
        try builder.prep(4, 12);
        try builder.prepend(f32, self.x);
        try builder.prepend(f32, self.y);
        try builder.prepend(f32, self.z);
        return builder.offset();
    }
};

pub const PackedVec3 = struct {
    table: flatbufferz.Struct,

    const Self = @This();

    pub fn initRoot(bytes: []u8) Self {
        const offset = flatbufferz.encode.read(u32, bytes);
        return Self.initPos(bytes, offset);
    }

    pub fn initPos(bytes: []u8, pos: u32) Self {
        return .{ .table = .{ ._tab = .{ .bytes = bytes, .pos = pos } } };
    }

    pub fn x(self: Self) f32 {
        return self.table.read(f32, self.table._tab.pos + 0);
    }
    pub fn setX(self: Self, val: f32) void {
        self.table.mutate(f32, self.table._tab.pos + 0, val);
    }

    pub fn y(self: Self) f32 {
        return self.table.read(f32, self.table._tab.pos + 4);
    }
    pub fn setY(self: Self, val: f32) void {
        self.table.mutate(f32, self.table._tab.pos + 4, val);
    }

    pub fn z(self: Self) f32 {
        return self.table.read(f32, self.table._tab.pos + 8);
    }
    pub fn setZ(self: Self, val: f32) void {
        self.table.mutate(f32, self.table._tab.pos + 8, val);
    }
};
