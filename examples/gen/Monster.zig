//! generated by flatc-zig from monster.fbs

const flatbuffers = @import("flatbuffers");
const std = @import("std");
const types = @import("lib.zig");

pub const Monster = struct {
    pos: ?types.Vec3 = null,
    mana: i16 = 150,
    hp: i16 = 100,
    name: [:0]const u8,
    inventory: []u8,
    color: types.Color = @intToEnum(types.Color, 2),
    weapons: []types.Weapon,
    equipped: types.Equipment,
    path: []types.Vec3,
    rotation: ?types.Vec4 = null,

    const Self = @This();

    pub fn init(allocator: std.mem.Allocator, packed_: PackedMonster) !Self {
        return .{
            .pos = if (try packed_.pos()) |p| try types.Vec3.init(p) else null,
            .mana = try packed_.mana(),
            .hp = try packed_.hp(),
            .name = try packed_.name(),
            .inventory = try packed_.inventory(),
            .color = try packed_.color(),
            .weapons = try flatbuffers.unpackVector(allocator, types.Weapon, packed_, "weapons"),
            .equipped = try packed_.equipped(),
            .path = try flatbuffers.unpackArray(allocator, types.Vec3, try packed_.path()),
            .rotation = if (try packed_.rotation()) |r| try types.Vec4.init(r) else null,
        };
    }

    pub fn deinit(self: Self, allocator: std.mem.Allocator) void {
        allocator.free(self.weapons);
        allocator.free(self.path);
    }

    pub fn pack(self: Self, builder: *flatbuffers.Builder) !u32 {
        const field_offsets = .{
            .weapons = try builder.prependVectorOffsets(types.Weapon, self.weapons),
            .inventory = try builder.prependVector(u8, self.inventory),
            .equipped = try self.equipped.pack(builder),
            .name = try builder.prependString(self.name),
            .path = try builder.prependVector(types.Vec3, self.path),
        };

        try builder.startTable();
        try builder.appendTableField(?types.Vec3, self.pos);
        try builder.appendTableField(i16, self.mana);
        try builder.appendTableField(i16, self.hp);
        try builder.appendTableFieldOffset(field_offsets.name);
        try builder.appendTableFieldOffset(0);
        try builder.appendTableFieldOffset(field_offsets.inventory);
        try builder.appendTableField(types.Color, self.color);
        try builder.appendTableFieldOffset(field_offsets.weapons);
        try builder.appendTableField(types.Equipment.Tag, self.equipped_type);
        try builder.appendTableFieldOffset(field_offsets.equipped);
        try builder.appendTableFieldOffset(field_offsets.path);
        try builder.appendTableField(?types.Vec4, self.rotation);
        return builder.endTable();
    }
};

pub const PackedMonster = struct {
    table: flatbuffers.Table,

    const Self = @This();

    pub fn init(size_prefixed_bytes: []u8) !Self {
        return .{ .table = try flatbuffers.Table.init(size_prefixed_bytes) };
    }

    pub fn pos(self: Self) !?types.PackedVec3 {
        return self.table.readField(?types.PackedVec3, 0);
    }

    pub fn mana(self: Self) !i16 {
        return self.table.readFieldWithDefault(i16, 1, 150);
    }

    pub fn hp(self: Self) !i16 {
        return self.table.readFieldWithDefault(i16, 2, 100);
    }

    pub fn name(self: Self) ![:0]const u8 {
        return self.table.readField([:0]const u8, 3);
    }

    pub fn inventory(self: Self) ![]align(1) u8 {
        return self.table.readField([]align(1) u8, 5);
    }

    pub fn color(self: Self) !types.Color {
        return self.table.readFieldWithDefault(types.Color, 6, @intToEnum(types.Color, 2));
    }

    pub fn weaponsLen(self: Self) !u32 {
        return self.table.readFieldVectorLen(7);
    }
    pub fn weapons(self: Self, index: usize) !types.PackedWeapon {
        return self.table.readFieldVectorItem(types.PackedWeapon, 7, index);
    }

    pub fn equippedType(self: Self) !types.Equipment.Tag {
        return self.table.readFieldWithDefault(types.Equipment.Tag, 8, @intToEnum(types.Equipment.Tag, 0));
    }

    pub fn equipped(self: Self) !types.PackedEquipment {
        return switch (try self.equippedType()) {
            inline else => |t| {
                var result = @unionInit(types.PackedEquipment, @tagName(t), undefined);
                const field = &@field(result, @tagName(t));
                field.* = try self.table.readField(@TypeOf(field.*), 9);
                return result;
            },
        };
    }

    pub fn path(self: Self) ![]align(1) types.PackedVec3 {
        return self.table.readField([]align(1) types.PackedVec3, 10);
    }

    pub fn rotation(self: Self) !?types.PackedVec4 {
        return self.table.readField(?types.PackedVec4, 11);
    }
};
