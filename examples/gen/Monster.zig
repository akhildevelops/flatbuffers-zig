//!
//! generated by flatc-zig
//! binary:     ./examples/monster/monster.fbs
//! schema:     monster.fbs
//! file ident: //monster.fbs
//! typename    Monster
//!

const flatbufferz = @import("flatbufferz");
const Types = @import("lib fname");

pub const file_ident: flatbufferz.Builder.Fid = "".*;
pub const file_ext = "";

pub const Monster = struct {
    pos: ?Types.Vec3,
    mana: i16,
    hp: i16,
    name: []const u8,
    inventory: []u8,
    color: Types.Color,
    weapons: []Types.Weapon,
    equipped_type: Types.PackedEquipment.Tag,
    equipped: ?Types.Equipment,
    path: []Types.Vec3,
    rotation: ?Types.Vec4,

    const Self = @This();

    pub fn init(packed_struct: PackedMonster) !Self {
        return .{
            .color = packed_struct.color(),
            .equipped = packed_struct.equipped(),
            .friendly = packed_struct.friendly(),
            .hp = packed_struct.hp(),
            .inventory = packed_struct.inventory(),
            .mana = packed_struct.mana(),
            .name = packed_struct.name(),
            .path = packed_struct.path(),
            .pos = packed_struct.pos(),
            .rotation = packed_struct.rotation(),
            .weapons = packed_struct.weapons(),
        };
    }

    pub fn pack(self: Self, builder: *flatbufferz.Builder) !u32 {
        const field_offsets = .{
            .weapons = try builder.createVector(Types.Weapon, self.weapons, 4, 1),
            .inventory = try builder.createVector(u8, self.inventory, 1, 1),
            .rotation = try self.rotation.pack(builder),
            .pos = try self.pos.pack(builder),
            .equipped = try self.equipped.pack(builder),
            .name = try builder.createString(self.name),
            .path = try builder.createVector(Types.Vec3, self.path, 12, 1),
        };

        try builder.startObject(12);
        try builder.prependSlotUOff(0, field_offsets.pos);
        try builder.prependSlot(i16, 1, self.mana, 150);
        try builder.prependSlot(i16, 2, self.hp, 100);
        try builder.prependSlotUOff(3, field_offsets.name, 0);
        try builder.prependSlot(bool, 4, self.friendly, false);
        try builder.prependSlotUOff(5, field_offsets.inventory, 0);
        try builder.prependSlot(Types.Color, 6, self.color, @intToEnum(Types.Color, 2));
        try builder.prependSlotUOff(7, field_offsets.weapons, 0);
        try builder.prependSlot(Types.PackedEquipment.Tag, 8, self.equipped_type, @intToEnum(Types.PackedEquipment.Tag, 0));
        try builder.prependSlotUOff(9, field_offsets.equipped);
        try builder.prependSlotUOff(10, field_offsets.path, 0);
        try builder.prependSlotUOff(11, field_offsets.rotation);
        return builder.endObject();
    }
};

pub const PackedMonster = struct {
    table: flatbufferz.Table,

    const Self = @This();

    pub fn initRoot(bytes: []u8) Self {
        const offset = flatbufferz.encode.read(u32, bytes);
        return Self.initPos(bytes, offset);
    }

    pub fn initPos(bytes: []u8, pos_: u32) Self {
        return .{ .table = .{ .bytes = bytes, .pos = pos_ } };
    }

    pub fn pos(self: Self) ?Types.PackedVec3 {
        const offset0 = self.table.offset(4);
        if (offset0 == 0) return null;
        const offset1 = self.table.indirect(offset0 + self.table.pos);
        return Types.PackedVec3.initPos(self.table.bytes, offset1);
    }

    pub fn mana(self: Self) i16 {
        const offset0 = self.table.offset(6);
        if (offset0 == 0) return 150;
        return self.table.read(i16, self.table.pos + offset0);
    }
    pub fn setMana(self: Self, val_: i16) void {
        self.table.mutateSlot(i16, 6, val_);
    }

    pub fn hp(self: Self) i16 {
        const offset0 = self.table.offset(8);
        if (offset0 == 0) return 100;
        return self.table.read(i16, self.table.pos + offset0);
    }
    pub fn setHp(self: Self, val_: i16) void {
        self.table.mutateSlot(i16, 8, val_);
    }

    pub fn name(self: Self) []const u8 {
        const offset0 = self.table.offset(10);
        if (offset0 == 0) return "";
        return self.table.byteVector(offset0 + self.table.pos);
    }

    pub fn inventory(self: Self, i: usize) ?u8 {
        const offset0 = self.table.offset(14);
        if (offset0 == 0) return null;

        var offset1 = self.table.vector(offset0);
        offset1 += @intCast(u32, i) * 1;
        offset1 = self.table.indirect(offset1);
        return u8.initPos(self.table.bytes, offset1);
    }

    pub fn inventoryLen(self: Self) usize {
        const offset0 = self.table.offset(14);
        if (offset0 == 0) return 0;
        return self.table.vectorLen(offset0);
    }

    pub fn color(self: Self) Types.Color {
        const offset0 = self.table.offset(16);
        if (offset0 == 0) return @intToEnum(Types.Color, 2);
        return self.table.read(Types.Color, self.table.pos + offset0);
    }
    pub fn setColor(self: Self, val_: Types.Color) void {
        self.table.mutateSlot(Types.Color, 16, val_);
    }

    pub fn weapons(self: Self, i: usize) ?Types.PackedWeapon {
        const offset0 = self.table.offset(18);
        if (offset0 == 0) return null;

        var offset1 = self.table.vector(offset0);
        offset1 += @intCast(u32, i) * 4;
        offset1 = self.table.indirect(offset1);
        return Types.PackedWeapon.initPos(self.table.bytes, offset1);
    }

    pub fn weaponsLen(self: Self) usize {
        const offset0 = self.table.offset(18);
        if (offset0 == 0) return 0;
        return self.table.vectorLen(offset0);
    }

    pub fn equippedType(self: Self) Types.PackedEquipment.Tag {
        const offset0 = self.table.offset(20);
        if (offset0 == 0) return @intToEnum(Types.PackedEquipment.Tag, 0);
        return self.table.read(Types.PackedEquipment.Tag, self.table.pos + offset0);
    }
    pub fn setEquippedType(self: Self, val_: Types.PackedEquipment.Tag) void {
        self.table.mutateSlot(Types.PackedEquipment.Tag, 20, val_);
    }

    pub fn equipped(self: Self) ?Types.PackedEquipment {
        const offset0 = self.table.offset(22);
        if (offset0 == 0) return null;
        const union_type = self.equippedType();
        const union_table = self.table.union_(offset0);
        return Types.PackedEquipment.init(union_type, union_table);
    }

    pub fn path(self: Self, i: usize) ?Types.PackedVec3 {
        const offset0 = self.table.offset(24);
        if (offset0 == 0) return null;

        var offset1 = self.table.vector(offset0);
        offset1 += @intCast(u32, i) * 12;
        return Types.PackedVec3.initPos(self.table.bytes, offset1);
    }

    pub fn pathLen(self: Self) usize {
        const offset0 = self.table.offset(24);
        if (offset0 == 0) return 0;
        return self.table.vectorLen(offset0);
    }

    pub fn rotation(self: Self) ?Types.PackedVec4 {
        const offset0 = self.table.offset(26);
        if (offset0 == 0) return null;
        const offset1 = self.table.indirect(offset0 + self.table.pos);
        return Types.PackedVec4.initPos(self.table.bytes, offset1);
    }
};
