//! generated by flatc-zig from File.fbs

const flatbuffers = @import("flatbuffers");
const std = @import("std");
const types = @import("lib.zig");

/// ----------------------------------------------------------------------
/// Arrow File metadata
///
pub const Footer = struct {
    version: types.MetadataVersion = .v1,
    schema: ?types.Schema = null,
    dictionaries: []types.Block,
    record_batches: []types.Block,
    /// User-defined metadata
    custom_metadata: []types.KeyValue,

    const Self = @This();

    pub fn init(allocator: std.mem.Allocator, packed_: PackedFooter) flatbuffers.Error!Self {
        const schema_ = if (try packed_.schema()) |s| try types.Schema.init(allocator, s) else null;
        errdefer {
            if (schema_) |s| s.deinit(allocator);
        }
        const dictionaries_ = try flatbuffers.unpackVector(allocator, types.Block, packed_, "dictionaries");
        errdefer {
            allocator.free(dictionaries_);
        }
        const record_batches_ = try flatbuffers.unpackVector(allocator, types.Block, packed_, "recordBatches");
        errdefer {
            allocator.free(record_batches_);
        }
        const custom_metadata_ = try flatbuffers.unpackVector(allocator, types.KeyValue, packed_, "customMetadata");
        errdefer {
            for (custom_metadata_) |c| c.deinit(allocator);
            allocator.free(custom_metadata_);
        }
        return .{
            .version = try packed_.version(),
            .schema = schema_,
            .dictionaries = dictionaries_,
            .record_batches = record_batches_,
            .custom_metadata = custom_metadata_,
        };
    }

    pub fn deinit(self: Self, allocator: std.mem.Allocator) void {
        if (self.schema) |s| s.deinit(allocator);
        allocator.free(self.dictionaries);
        allocator.free(self.record_batches);
        for (self.custom_metadata) |c| c.deinit(allocator);
        allocator.free(self.custom_metadata);
    }

    pub fn pack(self: Self, builder: *flatbuffers.Builder) flatbuffers.Error!u32 {
        const field_offsets = .{
            .schema = if (self.schema) |s| try s.pack(builder) else 0,
            .dictionaries = try builder.prependVector(types.Block, self.dictionaries),
            .record_batches = try builder.prependVector(types.Block, self.record_batches),
            .custom_metadata = try builder.prependVectorOffsets(types.KeyValue, self.custom_metadata),
        };

        try builder.startTable();
        try builder.appendTableFieldWithDefault(types.MetadataVersion, self.version, .v1);
        try builder.appendTableFieldOffset(field_offsets.schema);
        try builder.appendTableFieldOffset(field_offsets.dictionaries);
        try builder.appendTableFieldOffset(field_offsets.record_batches);
        try builder.appendTableFieldOffset(field_offsets.custom_metadata);
        return builder.endTable();
    }
};

/// ----------------------------------------------------------------------
/// Arrow File metadata
///
pub const PackedFooter = struct {
    table: flatbuffers.Table,

    const Self = @This();

    pub fn init(size_prefixed_bytes: []u8) flatbuffers.Error!Self {
        return .{ .table = try flatbuffers.Table.init(size_prefixed_bytes) };
    }

    pub fn version(self: Self) flatbuffers.Error!types.MetadataVersion {
        return self.table.readFieldWithDefault(types.MetadataVersion, 0, .v1);
    }

    pub fn schema(self: Self) flatbuffers.Error!?types.PackedSchema {
        return self.table.readField(?types.PackedSchema, 1);
    }

    pub fn dictionaries(self: Self) flatbuffers.Error![]align(1) types.Block {
        return self.table.readField([]align(1) types.Block, 2);
    }

    pub fn recordBatches(self: Self) flatbuffers.Error![]align(1) types.Block {
        return self.table.readField([]align(1) types.Block, 3);
    }

    /// User-defined metadata
    pub fn customMetadataLen(self: Self) flatbuffers.Error!u32 {
        return self.table.readFieldVectorLen(4);
    }
    pub fn customMetadata(self: Self, index: usize) flatbuffers.Error!types.PackedKeyValue {
        return self.table.readFieldVectorItem(types.PackedKeyValue, 4, index);
    }
};
