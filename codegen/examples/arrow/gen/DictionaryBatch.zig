//! generated by flatc-zig from Message.fbs

const flatbuffers = @import("flatbuffers");
const std = @import("std");
const types = @import("lib.zig");

/// For sending dictionary encoding information. Any Field can be
/// dictionary-encoded, but in this case none of its children may be
/// dictionary-encoded.
/// There is one vector / column per dictionary, but that vector / column
/// may be spread across multiple dictionary batches by using the isDelta
/// flag
pub const DictionaryBatch = struct {
    id: i64 = 0,
    data: ?types.RecordBatch = null,
    /// If isDelta is true the values in the dictionary are to be appended to a
    /// dictionary with the indicated id. If isDelta is false this dictionary
    /// should replace the existing dictionary.
    is_delta: bool = false,

    const Self = @This();

    pub fn init(allocator: std.mem.Allocator, packed_: PackedDictionaryBatch) flatbuffers.Error!Self {
        const data_ = if (try packed_.data()) |d| try types.RecordBatch.init(allocator, d) else null;
        errdefer {
            if (data_) |d| d.deinit(allocator);
        }
        return .{
            .id = try packed_.id(),
            .data = data_,
            .is_delta = try packed_.isDelta(),
        };
    }

    pub fn deinit(self: Self, allocator: std.mem.Allocator) void {
        if (self.data) |d| d.deinit(allocator);
    }

    pub fn pack(self: Self, builder: *flatbuffers.Builder) flatbuffers.Error!u32 {
        const field_offsets = .{
            .data = if (self.data) |d| try d.pack(builder) else 0,
        };

        try builder.startTable();
        try builder.appendTableFieldWithDefault(i64, self.id, 0);
        try builder.appendTableFieldOffset(field_offsets.data);
        try builder.appendTableFieldWithDefault(bool, self.is_delta, false);
        return builder.endTable();
    }
};

/// For sending dictionary encoding information. Any Field can be
/// dictionary-encoded, but in this case none of its children may be
/// dictionary-encoded.
/// There is one vector / column per dictionary, but that vector / column
/// may be spread across multiple dictionary batches by using the isDelta
/// flag
pub const PackedDictionaryBatch = struct {
    table: flatbuffers.Table,

    const Self = @This();

    pub fn init(size_prefixed_bytes: []u8) flatbuffers.Error!Self {
        return .{ .table = try flatbuffers.Table.init(size_prefixed_bytes) };
    }

    pub fn id(self: Self) flatbuffers.Error!i64 {
        return self.table.readFieldWithDefault(i64, 0, 0);
    }

    pub fn data(self: Self) flatbuffers.Error!?types.PackedRecordBatch {
        return self.table.readField(?types.PackedRecordBatch, 1);
    }

    /// If isDelta is true the values in the dictionary are to be appended to a
    /// dictionary with the indicated id. If isDelta is false this dictionary
    /// should replace the existing dictionary.
    pub fn isDelta(self: Self) flatbuffers.Error!bool {
        return self.table.readFieldWithDefault(bool, 2, false);
    }
};
